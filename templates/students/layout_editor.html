import React, { useState, useRef, useEffect } from 'react';
import { Save, Plus, Trash2, RotateCw, Copy, Grid, Settings, Eye, EyeOff, Undo, Redo, Download, Upload } from 'lucide-react';

const LayoutEditor = () => {
  // State for API integration
  const [apiToken, setApiToken] = useState(localStorage.getItem('access_token'));
  const [selectedClass, setSelectedClass] = useState(null);
  const [currentAssignments, setCurrentAssignments] = useState([]);
  const [validationErrors, setValidationErrors] = useState([]);

  // API functions for seat validation and assignment checking
  const validateSeatAssignment = async (seatId, classId) => {
    if (!apiToken || !classId) return { valid: true, message: '' };
    
    try {
      const response = await fetch(`/api/classes/${classId}/validate-seat/${seatId}/`, {
        headers: {
          'Authorization': `Bearer ${apiToken}`
        }
      });
      
      if (response.ok) {
        return await response.json();
      }
      return { valid: true, message: 'Cannot validate - API unavailable' };
    } catch (error) {
      console.warn('Seat validation failed:', error);
      return { valid: true, message: 'Validation unavailable' };
    }
  };

  const fetchCurrentAssignments = async (classId) => {
    if (!apiToken || !classId) return [];
    
    try {
      const response = await fetch(`/api/classes/${classId}/seating_chart/`, {
        headers: {
          'Authorization': `Bearer ${apiToken}`
        }
      });
      
      if (response.ok) {
        const chartData = await response.json();
        const assignments = [];
        
        // Extract assignments from chart data
        chartData.tables?.forEach(table => {
          table.seats?.forEach(seat => {
            if (seat.student) {
              assignments.push({
                seat_id: seat.absolute_seat_id,
                student_name: seat.student.name,
                group_number: seat.student.group_number,
                group_role: seat.student.group_role
              });
            }
          });
        });
        
        return assignments;
      }
    } catch (error) {
      console.warn('Failed to fetch current assignments:', error);
    }
    
    return [];
  };

  // Check if a seat is currently occupied
  const isSeatOccupied = (seatId) => {
    return currentAssignments.some(assignment => assignment.seat_id === seatId);
  };

  // Get student info for a seat
  const getStudentForSeat = (seatId) => {
    return currentAssignments.find(assignment => assignment.seat_id === seatId);
  };

  // Validate entire layout against current assignments
  const validateLayoutIntegrity = async () => {
    if (!selectedClass) {
      setValidationErrors(['No class selected for validation']);
      return;
    }

    const errors = [];
    const availableSeatIds = getAllSeatIds();
    
    // Check for assignments to non-existent seats
    for (const assignment of currentAssignments) {
      if (!availableSeatIds.includes(assignment.seat_id)) {
        errors.push(`Student ${assignment.student_name} assigned to non-existent seat ${assignment.seat_id}`);
      }
    }
    
    // Check for accessibility requirements
    const accessibleSeats = availableSeatIds.filter(seatId => {
      const seatInfo = getSeatInfo(seatId);
      return seatInfo?.isAccessible;
    });
    
    if (accessibleSeats.length === 0 && currentAssignments.length > 0) {
      errors.push('No accessible seats available - consider marking some seats as wheelchair accessible');
    }
    
    setValidationErrors(errors);
    
    if (errors.length === 0) {
      alert('âœ… Layout validation passed! All seat assignments are compatible.');
    } else {
      alert(`âš ï¸ Found ${errors.length} validation issue(s). Check the validation panel.`);
    }
  };

  // Load assignments when class is selected
  useEffect(() => {
    if (selectedClass) {
      fetchCurrentAssignments(selectedClass.id).then(setCurrentAssignments);
    }
  }, [selectedClass, apiToken]);
    id: null,
    name: 'New Classroom Layout',
    description: '',
    room_width: 15,
    room_height: 10,
    tables: [],
    obstacles: []
  });

  // Editor state
  const [selectedTool, setSelectedTool] = useState('select'); // select, table, obstacle
  const [selectedItem, setSelectedItem] = useState(null);
  const [draggedItem, setDraggedItem] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [showGrid, setShowGrid] = useState(true);
  const [snapToGrid, setSnapToGrid] = useState(true);
  const [isPreviewMode, setIsPreviewMode] = useState(false);
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  
  // Refs
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);

  // Constants
  const GRID_SIZE = 40;
  const TABLE_SHAPES = [
    { id: 'rectangular', name: 'Rectangular', icon: 'â¬œ' },
    { id: 'round', name: 'Round', icon: 'â­•' },
    { id: 'u_shaped', name: 'U-Shaped', icon: 'ðŸ”„' },
    { id: 'individual', name: 'Individual', icon: 'ðŸ“¦' }
  ];

  const OBSTACLE_TYPES = [
    { id: 'teacher_desk', name: 'Teacher Desk', color: '#8B4513', icon: 'ðŸª‘' },
    { id: 'cabinet', name: 'Cabinet', color: '#654321', icon: 'ðŸ—„ï¸' },
    { id: 'bookshelf', name: 'Bookshelf', color: '#A0522D', icon: 'ðŸ“š' },
    { id: 'door', name: 'Door', color: '#228B22', icon: 'ðŸšª' },
    { id: 'window', name: 'Window', color: '#87CEEB', icon: 'ðŸªŸ' },
    { id: 'whiteboard', name: 'Whiteboard', color: '#F5F5F5', icon: 'ðŸ“‹' },
    { id: 'projector', name: 'Projector', color: '#696969', icon: 'ðŸ“½ï¸' },
    { id: 'other', name: 'Other', color: '#808080', icon: 'â¬›' }
  ];

  // Helper functions
  const getMousePosition = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  };

  const screenToGrid = (x, y) => {
    return {
      x: Math.floor(x / GRID_SIZE),
      y: Math.floor(y / GRID_SIZE)
    };
  };

  const gridToScreen = (x, y) => {
    return {
      x: x * GRID_SIZE,
      y: y * GRID_SIZE
    };
  };

  const snapToGridIfEnabled = (x, y) => {
    if (snapToGrid) {
      return {
        x: Math.round(x / GRID_SIZE) * GRID_SIZE,
        y: Math.round(y / GRID_SIZE) * GRID_SIZE
      };
    }
    return { x, y };
  };

  // History management
  const saveToHistory = () => {
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(JSON.parse(JSON.stringify(layout)));
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const undo = () => {
    if (historyIndex > 0) {
      setHistoryIndex(historyIndex - 1);
      setLayout(JSON.parse(JSON.stringify(history[historyIndex - 1])));
    }
  };

  const redo = () => {
    if (historyIndex < history.length - 1) {
      setHistoryIndex(historyIndex + 1);
      setLayout(JSON.parse(JSON.stringify(history[historyIndex + 1])));
    }
  };

  // Item creation
  // Generate seat positions based on table shape and max_seats
  const generateSeats = (tableShape, maxSeats, width = 2, height = 2) => {
    const seats = [];
    
    if (tableShape === 'rectangular') {
      // For rectangular tables, arrange seats around perimeter
      if (maxSeats <= 2) {
        seats.push(
          { seat_number: 1, relative_x: 0.25, relative_y: 0.5, is_accessible: true },
          { seat_number: 2, relative_x: 0.75, relative_y: 0.5, is_accessible: true }
        );
      } else if (maxSeats <= 4) {
        seats.push(
          { seat_number: 1, relative_x: 0.25, relative_y: 0.25, is_accessible: true },
          { seat_number: 2, relative_x: 0.75, relative_y: 0.25, is_accessible: true },
          { seat_number: 3, relative_x: 0.25, relative_y: 0.75, is_accessible: true },
          { seat_number: 4, relative_x: 0.75, relative_y: 0.75, is_accessible: true }
        );
      } else if (maxSeats <= 6) {
        seats.push(
          { seat_number: 1, relative_x: 0.2, relative_y: 0.2, is_accessible: true },
          { seat_number: 2, relative_x: 0.5, relative_y: 0.1, is_accessible: true },
          { seat_number: 3, relative_x: 0.8, relative_y: 0.2, is_accessible: true },
          { seat_number: 4, relative_x: 0.2, relative_y: 0.8, is_accessible: true },
          { seat_number: 5, relative_x: 0.5, relative_y: 0.9, is_accessible: true },
          { seat_number: 6, relative_x: 0.8, relative_y: 0.8, is_accessible: true }
        );
      } else {
        // 8 seats - around perimeter
        seats.push(
          { seat_number: 1, relative_x: 0.15, relative_y: 0.15, is_accessible: true },
          { seat_number: 2, relative_x: 0.5, relative_y: 0.1, is_accessible: true },
          { seat_number: 3, relative_x: 0.85, relative_y: 0.15, is_accessible: true },
          { seat_number: 4, relative_x: 0.9, relative_y: 0.5, is_accessible: true },
          { seat_number: 5, relative_x: 0.85, relative_y: 0.85, is_accessible: true },
          { seat_number: 6, relative_x: 0.5, relative_y: 0.9, is_accessible: true },
          { seat_number: 7, relative_x: 0.15, relative_y: 0.85, is_accessible: true },
          { seat_number: 8, relative_x: 0.1, relative_y: 0.5, is_accessible: true }
        );
      }
    } else if (tableShape === 'round') {
      // Arrange seats in a circle
      for (let i = 0; i < maxSeats; i++) {
        const angle = (i * 2 * Math.PI) / maxSeats - Math.PI / 2; // Start from top
        const radius = 0.35; // Distance from center
        const x = 0.5 + radius * Math.cos(angle);
        const y = 0.5 + radius * Math.sin(angle);
        seats.push({
          seat_number: i + 1,
          relative_x: Math.max(0.1, Math.min(0.9, x)),
          relative_y: Math.max(0.1, Math.min(0.9, y)),
          is_accessible: true
        });
      }
    } else if (tableShape === 'u_shaped') {
      // U-shaped arrangement
      if (maxSeats <= 4) {
        seats.push(
          { seat_number: 1, relative_x: 0.2, relative_y: 0.8, is_accessible: true },
          { seat_number: 2, relative_x: 0.2, relative_y: 0.2, is_accessible: true },
          { seat_number: 3, relative_x: 0.8, relative_y: 0.2, is_accessible: true },
          { seat_number: 4, relative_x: 0.8, relative_y: 0.8, is_accessible: true }
        );
      } else {
        // More seats for larger U-shape
        for (let i = 0; i < maxSeats; i++) {
          let x, y;
          const seatsPerSide = Math.ceil(maxSeats / 3);
          
          if (i < seatsPerSide) {
            // Left side
            x = 0.15;
            y = 0.2 + (i * 0.6) / (seatsPerSide - 1);
          } else if (i < seatsPerSide * 2) {
            // Bottom
            const bottomIndex = i - seatsPerSide;
            x = 0.15 + (bottomIndex * 0.7) / (seatsPerSide - 1);
            y = 0.85;
          } else {
            // Right side
            const rightIndex = i - seatsPerSide * 2;
            x = 0.85;
            y = 0.8 - (rightIndex * 0.6) / (maxSeats - seatsPerSide * 2 - 1);
          }
          
          seats.push({
            seat_number: i + 1,
            relative_x: Math.max(0.1, Math.min(0.9, x)),
            relative_y: Math.max(0.1, Math.min(0.9, y)),
            is_accessible: true
          });
        }
      }
    } else if (tableShape === 'individual') {
      // Single seat in center
      seats.push({
        seat_number: 1,
        relative_x: 0.5,
        relative_y: 0.5,
        is_accessible: true
      });
    }
    
    return seats.slice(0, maxSeats); // Ensure we don't exceed max_seats
  };

  const createTable = (x, y) => {
    const gridPos = screenToGrid(x, y);
    const tableNumber = layout.tables.length + 1;
    const maxSeats = 4;
    const tableShape = 'rectangular';
    
    const newTable = {
      id: Date.now(),
      table_number: tableNumber,
      table_name: `Table ${tableNumber}`,
      x_position: Math.max(0, Math.min(gridPos.x, layout.room_width - 2)),
      y_position: Math.max(0, Math.min(gridPos.y, layout.room_height - 2)),
      width: 2,
      height: 2,
      max_seats: maxSeats,
      table_shape: tableShape,
      rotation: 0,
      seats: generateSeats(tableShape, maxSeats, 2, 2)
    };
    
    saveToHistory();
    setLayout(prev => ({
      ...prev,
      tables: [...prev.tables, newTable]
    }));
    setSelectedItem({ type: 'table', item: newTable });
  };

  const createObstacle = (x, y) => {
    const gridPos = screenToGrid(x, y);
    const obstacleType = OBSTACLE_TYPES[0];
    const newObstacle = {
      id: Date.now(),
      name: obstacleType.name,
      obstacle_type: obstacleType.id,
      x_position: Math.max(0, Math.min(gridPos.x, layout.room_width - 1)),
      y_position: Math.max(0, Math.min(gridPos.y, layout.room_height - 1)),
      width: 1,
      height: 1,
      color: obstacleType.color
    };
    
    saveToHistory();
    setLayout(prev => ({
      ...prev,
      obstacles: [...prev.obstacles, newObstacle]
    }));
    setSelectedItem({ type: 'obstacle', item: newObstacle });
  };

  // Item manipulation
  const deleteSelectedItem = () => {
    if (!selectedItem) return;
    
    saveToHistory();
    if (selectedItem.type === 'table') {
      setLayout(prev => ({
        ...prev,
        tables: prev.tables.filter(t => t.id !== selectedItem.item.id)
      }));
    } else if (selectedItem.type === 'obstacle') {
      setLayout(prev => ({
        ...prev,
        obstacles: prev.obstacles.filter(o => o.id !== selectedItem.item.id)
      }));
    }
    setSelectedItem(null);
  };

  const duplicateSelectedItem = () => {
    if (!selectedItem) return;
    
    saveToHistory();
    if (selectedItem.type === 'table') {
      const newTable = {
        ...selectedItem.item,
        id: Date.now(),
        table_number: layout.tables.length + 1,
        table_name: `${selectedItem.item.table_name} Copy`,
        x_position: Math.min(selectedItem.item.x_position + 1, layout.room_width - selectedItem.item.width),
        y_position: Math.min(selectedItem.item.y_position + 1, layout.room_height - selectedItem.item.height)
      };
      setLayout(prev => ({
        ...prev,
        tables: [...prev.tables, newTable]
      }));
      setSelectedItem({ type: 'table', item: newTable });
    } else if (selectedItem.type === 'obstacle') {
      const newObstacle = {
        ...selectedItem.item,
        id: Date.now(),
        name: `${selectedItem.item.name} Copy`,
        x_position: Math.min(selectedItem.item.x_position + 1, layout.room_width - selectedItem.item.width),
        y_position: Math.min(selectedItem.item.y_position + 1, layout.room_height - selectedItem.item.height)
      };
      setLayout(prev => ({
        ...prev,
        obstacles: [...prev.obstacles, newObstacle]
      }));
      setSelectedItem({ type: 'obstacle', item: newObstacle });
    }
  };

  const rotateSelectedTable = () => {
    if (!selectedItem || selectedItem.type !== 'table') return;
    
    saveToHistory();
    const rotations = [0, 90, 180, 270];
    const currentIndex = rotations.indexOf(selectedItem.item.rotation);
    const newRotation = rotations[(currentIndex + 1) % rotations.length];
    
    setLayout(prev => ({
      ...prev,
      tables: prev.tables.map(t => 
        t.id === selectedItem.item.id 
          ? { ...t, rotation: newRotation }
          : t
      )
    }));
    
    setSelectedItem(prev => ({
      ...prev,
      item: { ...prev.item, rotation: newRotation }
    }));
  };

  // Event handlers
  const handleCanvasClick = (e) => {
    const pos = getMousePosition(e);
    
    if (selectedTool === 'table') {
      createTable(pos.x, pos.y);
    } else if (selectedTool === 'obstacle') {
      createObstacle(pos.x, pos.y);
    } else if (selectedTool === 'select') {
      // Check if clicking on an item
      let clickedItem = null;
      
      // Check tables
      for (const table of layout.tables) {
        const screenPos = gridToScreen(table.x_position, table.y_position);
        if (pos.x >= screenPos.x && pos.x <= screenPos.x + (table.width * GRID_SIZE) &&
            pos.y >= screenPos.y && pos.y <= screenPos.y + (table.height * GRID_SIZE)) {
          clickedItem = { type: 'table', item: table };
          break;
        }
      }
      
      // Check obstacles if no table clicked
      if (!clickedItem) {
        for (const obstacle of layout.obstacles) {
          const screenPos = gridToScreen(obstacle.x_position, obstacle.y_position);
          if (pos.x >= screenPos.x && pos.x <= screenPos.x + (obstacle.width * GRID_SIZE) &&
              pos.y >= screenPos.y && pos.y <= screenPos.y + (obstacle.height * GRID_SIZE)) {
            clickedItem = { type: 'obstacle', item: obstacle };
            break;
          }
        }
      }
      
      setSelectedItem(clickedItem);
    }
  };

  const handleMouseDown = (e) => {
    if (selectedTool !== 'select' || !selectedItem) return;
    
    const pos = getMousePosition(e);
    const screenPos = gridToScreen(selectedItem.item.x_position, selectedItem.item.y_position);
    
    if (pos.x >= screenPos.x && pos.x <= screenPos.x + (selectedItem.item.width * GRID_SIZE) &&
        pos.y >= screenPos.y && pos.y <= screenPos.y + (selectedItem.item.height * GRID_SIZE)) {
      setDraggedItem(selectedItem);
      setDragOffset({
        x: pos.x - screenPos.x,
        y: pos.y - screenPos.y
      });
    }
  };

  const handleMouseMove = (e) => {
    if (!draggedItem) return;
    
    const pos = getMousePosition(e);
    const newPos = snapToGridIfEnabled(
      pos.x - dragOffset.x,
      pos.y - dragOffset.y
    );
    const gridPos = screenToGrid(newPos.x, newPos.y);
    
    // Constrain to room bounds
    const constrainedX = Math.max(0, Math.min(gridPos.x, layout.room_width - draggedItem.item.width));
    const constrainedY = Math.max(0, Math.min(gridPos.y, layout.room_height - draggedItem.item.height));
    
    if (draggedItem.type === 'table') {
      setLayout(prev => ({
        ...prev,
        tables: prev.tables.map(t => 
          t.id === draggedItem.item.id 
            ? { ...t, x_position: constrainedX, y_position: constrainedY }
            : t
        )
      }));
    } else if (draggedItem.type === 'obstacle') {
      setLayout(prev => ({
        ...prev,
        obstacles: prev.obstacles.map(o => 
          o.id === draggedItem.item.id 
            ? { ...o, x_position: constrainedX, y_position: constrainedY }
            : o
        )
      }));
    }
    
    setSelectedItem(prev => ({
      ...prev,
      item: { ...prev.item, x_position: constrainedX, y_position: constrainedY }
    }));
  };

  const handleMouseUp = () => {
    if (draggedItem) {
      saveToHistory();
    }
    setDraggedItem(null);
    setDragOffset({ x: 0, y: 0 });
  };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 'z':
            e.preventDefault();
            if (e.shiftKey) {
              redo();
            } else {
              undo();
            }
            break;
          case 'y':
            e.preventDefault();
            redo();
            break;
          case 'd':
            e.preventDefault();
            duplicateSelectedItem();
            break;
        }
      } else {
        switch (e.key) {
          case 'Delete':
          case 'Backspace':
            e.preventDefault();
            deleteSelectedItem();
            break;
          case 'r':
            e.preventDefault();
            rotateSelectedTable();
            break;
          case 'Escape':
            setSelectedItem(null);
            setSelectedTool('select');
            break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedItem, historyIndex, history]);

  // Helper function to get all available seat IDs in the layout
  const getAllSeatIds = () => {
    const seatIds = [];
    layout.tables.forEach(table => {
      table.seats?.forEach(seat => {
        seatIds.push(`${table.table_number}-${seat.seat_number}`);
      });
    });
    return seatIds;
  };

  // Helper function to validate if a seat ID exists in the layout
  const validateSeatId = (seatId) => {
    const [tableNum, seatNum] = seatId.split('-').map(Number);
    const table = layout.tables.find(t => t.table_number === tableNum);
    if (!table) return false;
    const seat = table.seats?.find(s => s.seat_number === seatNum);
    return !!seat;
  };

  // Helper function to get seat information
  const getSeatInfo = (seatId) => {
    const [tableNum, seatNum] = seatId.split('-').map(Number);
    const table = layout.tables.find(t => t.table_number === tableNum);
    if (!table) return null;
    const seat = table.seats?.find(s => s.seat_number === seatNum);
    if (!seat) return null;
    
    return {
      table: table,
      seat: seat,
      seatId: seatId,
      isAccessible: seat.is_accessible,
      tableShape: table.table_shape,
      tableName: table.table_name
    };
  };

  // Function to export layout in API-compatible format
  const exportForAPI = () => {
    return {
      name: layout.name,
      description: layout.description,
      room_width: layout.room_width,
      room_height: layout.room_height,
      is_template: false, // Set based on your needs
      tables: layout.tables.map(table => ({
        table_number: table.table_number,
        table_name: table.table_name,
        x_position: table.x_position,
        y_position: table.y_position,
        width: table.width,
        height: table.height,
        max_seats: table.max_seats,
        table_shape: table.table_shape,
        rotation: table.rotation,
        seats: table.seats?.map(seat => ({
          seat_number: seat.seat_number,
          relative_x: seat.relative_x,
          relative_y: seat.relative_y,
          is_accessible: seat.is_accessible,
          notes: seat.notes || ''
        })) || []
      })),
      obstacles: layout.obstacles.map(obstacle => ({
        name: obstacle.name,
        obstacle_type: obstacle.obstacle_type,
        x_position: obstacle.x_position,
        y_position: obstacle.y_position,
        width: obstacle.width,
        height: obstacle.height,
        color: obstacle.color
      }))
    };
  };
    const dataStr = JSON.stringify(layout, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${layout.name.replace(/\s+/g, '_')}.json`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const importLayout = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const importedLayout = JSON.parse(event.target.result);
        saveToHistory();
        setLayout(importedLayout);
        setSelectedItem(null);
      } catch (error) {
        alert('Error importing layout: Invalid file format');
      }
    };
    reader.readAsText(file);
  };

  // Initialize history
  useEffect(() => {
    if (history.length === 0) {
      setHistory([JSON.parse(JSON.stringify(layout))]);
      setHistoryIndex(0);
    }
  }, []);

  return (
    <div className="flex h-screen bg-gray-100">
      {/* Toolbar */}
      <div className="w-80 bg-white shadow-lg flex flex-col">
        {/* Header */}
        <div className="p-4 border-b border-gray-200">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-bold text-gray-800">Layout Editor</h2>
            <div className="flex gap-2">
              <button
                onClick={() => setIsPreviewMode(!isPreviewMode)}
                className={`p-2 rounded-lg transition-colors ${
                  isPreviewMode 
                    ? 'bg-blue-100 text-blue-600' 
                    : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                }`}
                title={isPreviewMode ? 'Exit Preview' : 'Preview Mode'}
              >
                {isPreviewMode ? <EyeOff size={18} /> : <Eye size={18} />}
              </button>
                </div>
          )}
        </div>
          </div>
          
          {/* Layout Info */}
          <div className="space-y-3">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Layout Name
              </label>
              <input
                type="text"
                value={layout.name}
                onChange={(e) => setLayout(prev => ({ ...prev, name: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="Enter layout name"
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Description
              </label>
              <textarea
                value={layout.description}
                onChange={(e) => setLayout(prev => ({ ...prev, description: e.target.value }))}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                rows={2}
                placeholder="Describe this layout"
              />
            </div>
            
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Width
                </label>
                <input
                  type="number"
                  value={layout.room_width}
                  onChange={(e) => setLayout(prev => ({ ...prev, room_width: parseInt(e.target.value) || 15 }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  min="5"
                  max="30"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Height
                </label>
                <input
                  type="number"
                  value={layout.room_height}
                  onChange={(e) => setLayout(prev => ({ ...prev, room_height: parseInt(e.target.value) || 10 }))}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                  min="5"
                  max="20"
                />
              </div>
            </div>
          </div>
        </div>

        {/* Class Selection and Validation */}
        {!isPreviewMode && (
          <>
          <div className="p-4 border-b border-gray-200">
            <h3 className="text-lg font-semibold text-gray-800 mb-3">Class Integration</h3>
            
            {/* Class Selection */}
            <div className="space-y-3">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Select Class (Optional)
                </label>
                <select
                  value={selectedClass?.id || ''}
                  onChange={(e) => {
                    const classId = e.target.value;
                    if (classId) {
                      // In a real app, you'd fetch class details from API
                      setSelectedClass({ id: classId, name: `Class ${classId}` });
                    } else {
                      setSelectedClass(null);
                      setCurrentAssignments([]);
                    }
                  }}
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  <option value="">No class selected</option>
                  <option value="1">Math Class A</option>
                  <option value="2">Science Class B</option>
                  <option value="3">History Class C</option>
                </select>
              </div>
              
              {/* Validation Controls */}
              {selectedClass && (
                <div className="space-y-2">
                  <button
                    onClick={validateLayoutIntegrity}
                    className="w-full flex items-center justify-center gap-2 px-3 py-2 bg-orange-100 text-orange-700 rounded-lg hover:bg-orange-200 transition-colors font-medium"
                  >
                    <Settings size={16} />
                    Validate Layout
                  </button>
                  
                  {currentAssignments.length > 0 && (
                    <div className="text-xs text-gray-600 bg-blue-50 p-2 rounded">
                      ðŸ“Š {currentAssignments.length} students currently assigned
                    </div>
                  )}
                </div>
              )}
              
              {/* Validation Errors */}
              {validationErrors.length > 0 && (
                <div className="bg-red-50 border border-red-200 rounded-lg p-3">
                  <h4 className="text-sm font-semibold text-red-800 mb-2">
                    Validation Issues:
                  </h4>
                  <ul className="text-xs text-red-700 space-y-1">
                    {validationErrors.map((error, index) => (
                      <li key={index}>â€¢ {error}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          </div>
        )}
          <>
            {/* Tools */}
            <div className="p-4 border-b border-gray-200">
              <h3 className="text-lg font-semibold text-gray-800 mb-3">Tools</h3>
              <div className="grid grid-cols-3 gap-2">
                <button
                  onClick={() => setSelectedTool('select')}
                  className={`p-3 rounded-lg transition-colors ${
                    selectedTool === 'select' 
                      ? 'bg-blue-100 text-blue-600 border-2 border-blue-300' 
                      : 'bg-gray-50 text-gray-600 hover:bg-gray-100 border-2 border-transparent'
                  }`}
                  title="Select Tool"
                >
                  <div className="text-center">
                    <div className="text-xl mb-1">ðŸ‘†</div>
                    <div className="text-xs">Select</div>
                  </div>
                </button>
                
                <button
                  onClick={() => setSelectedTool('table')}
                  className={`p-3 rounded-lg transition-colors ${
                    selectedTool === 'table' 
                      ? 'bg-green-100 text-green-600 border-2 border-green-300' 
                      : 'bg-gray-50 text-gray-600 hover:bg-gray-100 border-2 border-transparent'
                  }`}
                  title="Add Table"
                >
                  <div className="text-center">
                    <div className="text-xl mb-1">ðŸª‘</div>
                    <div className="text-xs">Table</div>
                  </div>
                </button>
                
                <button
                  onClick={() => setSelectedTool('obstacle')}
                  className={`p-3 rounded-lg transition-colors ${
                    selectedTool === 'obstacle' 
                      ? 'bg-orange-100 text-orange-600 border-2 border-orange-300' 
                      : 'bg-gray-50 text-gray-600 hover:bg-gray-100 border-2 border-transparent'
                  }`}
                  title="Add Obstacle"
                >
                  <div className="text-center">
                    <div className="text-xl mb-1">ðŸ“¦</div>
                    <div className="text-xs">Object</div>
                  </div>
                </button>
              </div>
            </div>

            {/* Actions */}
            <div className="p-4 border-b border-gray-200">
              <h3 className="text-lg font-semibold text-gray-800 mb-3">Actions</h3>
              <div className="grid grid-cols-2 gap-2">
                <button
                  onClick={undo}
                  disabled={historyIndex <= 0}
                  className="flex items-center justify-center gap-2 px-3 py-2 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                  title="Undo (Ctrl+Z)"
                >
                  <Undo size={16} />
                  <span className="text-sm">Undo</span>
                </button>
                
                <button
                  onClick={redo}
                  disabled={historyIndex >= history.length - 1}
                  className="flex items-center justify-center gap-2 px-3 py-2 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                  title="Redo (Ctrl+Y)"
                >
                  <Redo size={16} />
                  <span className="text-sm">Redo</span>
                </button>
                
                <button
                  onClick={duplicateSelectedItem}
                  disabled={!selectedItem}
                  className="flex items-center justify-center gap-2 px-3 py-2 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                  title="Duplicate (Ctrl+D)"
                >
                  <Copy size={16} />
                  <span className="text-sm">Copy</span>
                </button>
                
                <button
                  onClick={deleteSelectedItem}
                  disabled={!selectedItem}
                  className="flex items-center justify-center gap-2 px-3 py-2 bg-red-100 text-red-600 rounded-lg hover:bg-red-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                  title="Delete (Del)"
                >
                  <Trash2 size={16} />
                  <span className="text-sm">Delete</span>
                </button>
                
                <button
                  onClick={rotateSelectedTable}
                  disabled={!selectedItem || selectedItem.type !== 'table'}
                  className="flex items-center justify-center gap-2 px-3 py-2 bg-blue-100 text-blue-600 rounded-lg hover:bg-blue-200 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                  title="Rotate Table (R)"
                >
                  <RotateCw size={16} />
                  <span className="text-sm">Rotate</span>
                </button>
                
                <button
                  onClick={() => setShowGrid(!showGrid)}
                  className={`flex items-center justify-center gap-2 px-3 py-2 rounded-lg transition-colors ${
                    showGrid 
                      ? 'bg-green-100 text-green-600' 
                      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`}
                  title="Toggle Grid"
                >
                  <Grid size={16} />
                  <span className="text-sm">Grid</span>
                </button>
              </div>
              
              <div className="mt-3">
                <label className="flex items-center gap-2 text-sm text-gray-600">
                  <input
                    type="checkbox"
                    checked={snapToGrid}
                    onChange={(e) => setSnapToGrid(e.target.checked)}
                    className="rounded"
                  />
                  Snap to Grid
                </label>
              </div>
            </div>

            {/* Properties Panel */}
            {selectedItem && (
              <div className="p-4 border-b border-gray-200">
                <h3 className="text-lg font-semibold text-gray-800 mb-3">Properties</h3>
                <div className="space-y-3">
                  {selectedItem.type === 'table' && (
                    <>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                          Table Name
                        </label>
                        <input
                          type="text"
                          value={selectedItem.item.table_name}
                          onChange={(e) => {
                            const newName = e.target.value;
                            setLayout(prev => ({
                              ...prev,
                              tables: prev.tables.map(t => 
                                t.id === selectedItem.item.id ? { ...t, table_name: newName } : t
                              )
                            }));
                            setSelectedItem(prev => ({
                              ...prev,
                              item: { ...prev.item, table_name: newName }
                            }));
                          }}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                          Shape
                        </label>
                        <select
                          value={selectedItem.item.table_shape}
                          onChange={(e) => {
                            const newShape = e.target.value;
                            const newSeats = generateSeats(
                              newShape, 
                              selectedItem.item.max_seats, 
                              selectedItem.item.width, 
                              selectedItem.item.height
                            );
                            
                            setLayout(prev => ({
                              ...prev,
                              tables: prev.tables.map(t => 
                                t.id === selectedItem.item.id 
                                  ? { ...t, table_shape: newShape, seats: newSeats } 
                                  : t
                              )
                            }));
                            setSelectedItem(prev => ({
                              ...prev,
                              item: { ...prev.item, table_shape: newShape, seats: newSeats }
                            }));
                          }}
                          className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        >
                          {TABLE_SHAPES.map(shape => (
                            <option key={shape.id} value={shape.id}>
                              {shape.icon} {shape.name}
                            </option>
                          ))}
                        </select>
                      </div>
                      
                      <div className="grid grid-cols-2 gap-2">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">
                            Width
                          </label>
                          <input
                            type="number"
                            value={selectedItem.item.width}
                            onChange={(e) => {
                              const newWidth = parseInt(e.target.value) || 1;
                              setLayout(prev => ({
                                ...prev,
                                tables: prev.tables.map(t => 
                                  t.id === selectedItem.item.id ? { ...t, width: newWidth } : t
                                )
                              }));
                              setSelectedItem(prev => ({
                                ...prev,
                                item: { ...prev.item, width: newWidth }
                              }));
                            }}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                            min="1"
                            max="5"
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-1">
                            Height
                          </label>
                          <input
                            type="number"
                            value={selectedItem.item.height}
                            onChange={(e) => {
                              const newHeight = parseInt(e.target.value) || 1;
                              setLayout(prev => ({
                                ...prev,
                                tables: prev.tables.map(t => 
                                  t.id === selectedItem.item.id ? { ...t, height: newHeight } : t
                                )
                              }));