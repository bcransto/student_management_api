<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Classroom Layout Editor</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .shadow-text {
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      // Import React hooks
      const { useState, useRef, useEffect, useCallback } = React;

      // Lucide React icons (inline definitions)
      const Save = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", {
            d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z",
          })
        );
      const Plus = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", { d: "M5 12h14" }),
          React.createElement("path", { d: "m12 5 0 14" })
        );
      const Trash2 = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", { d: "M3 6h18" }),
          React.createElement("path", {
            d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
          }),
          React.createElement("path", {
            d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
          }),
          React.createElement("line", { x1: 10, x2: 10, y1: 11, y2: 17 }),
          React.createElement("line", { x1: 14, x2: 14, y1: 11, y2: 17 })
        );
      const RotateCw = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", { d: "M21 2v6h-6" }),
          React.createElement("path", { d: "M3 12a9 9 0 0 1 15.71-5.74L21 9" }),
          React.createElement("path", { d: "M11 19.73A9 9 0 0 1 3 12" })
        );
      const Eye = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", {
            d: "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z",
          }),
          React.createElement("circle", { cx: 12, cy: 12, r: 3 })
        );
      const EyeOff = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", { d: "M9.88 9.88a3 3 0 1 0 4.24 4.24" }),
          React.createElement("path", {
            d: "M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 11 8 11 8a13.16 13.16 0 0 1-1.67 2.68",
          }),
          React.createElement("path", {
            d: "M6.61 6.61A13.526 13.526 0 0 0 1 12s4 8 11 8a9.74 9.74 0 0 0 5.39-1.61",
          }),
          React.createElement("line", { x1: 2, x2: 22, y1: 2, y2: 22 })
        );
      const Grid = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("rect", {
            width: 18,
            height: 18,
            x: 3,
            y: 3,
            rx: 2,
          }),
          React.createElement("path", { d: "M9 3v18" }),
          React.createElement("path", { d: "M15 3v18" }),
          React.createElement("path", { d: "M3 9h18" }),
          React.createElement("path", { d: "M3 15h18" })
        );
      const MousePointer = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", {
            d: "M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z",
          }),
          React.createElement("path", { d: "M13 13l6 6" })
        );
      const Table = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", {
            d: "M14 9V5a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v4",
          }),
          React.createElement("path", {
            d: "M14 9h6v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9h6",
          }),
          React.createElement("path", { d: "M6 14h8" })
        );
      const Square = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("rect", {
            width: 18,
            height: 18,
            x: 3,
            y: 3,
            rx: 2,
          })
        );
      const Upload = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", {
            d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
          }),
          React.createElement("polyline", { points: "17,8 12,3 7,8" }),
          React.createElement("line", { x1: 12, x2: 12, y1: 3, y2: 15 })
        );
      const Download = (props) =>
        React.createElement(
          "svg",
          {
            width: 24,
            height: 24,
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round",
            strokeLinejoin: "round",
            ...props,
          },
          React.createElement("path", {
            d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
          }),
          React.createElement("polyline", { points: "7,10 12,15 17,10" }),
          React.createElement("line", { x1: 12, x2: 12, y1: 15, y2: 3 })
        );

      // Main Layout Editor Component
      const LayoutEditor = () => {
        // Layout state
        const [layout, setLayout] = useState({
          id: null,
          name: "New Classroom Layout",
          description: "",
          room_width: 15,
          room_height: 10,
          tables: [],
          obstacles: [],
        });

        // Editor state
        const [selectedTool, setSelectedTool] = useState("select");
        const [selectedItem, setSelectedItem] = useState(null);
        const [showGrid, setShowGrid] = useState(true);
        const [snapToGrid, setSnapToGrid] = useState(true);
        const [isPreviewMode, setIsPreviewMode] = useState(false);
        const [history, setHistory] = useState([]);
        const [historyIndex, setHistoryIndex] = useState(-1);

        // Enhanced drag state - replaces draggedItem and dragOffset
        const [dragState, setDragState] = useState({
          isDragging: false,
          draggedItem: null,
          draggedType: null,
          startPosition: { x: 0, y: 0 },
          offset: { x: 0, y: 0 },
        });

        // Refs
        const canvasRef = useRef(null);
        const fileInputRef = useRef(null);

        // Constants
        const GRID_SIZE = 40;
        const TABLE_SHAPES = [
          { id: "rectangular", name: "Rectangular", icon: "⬜" },
          { id: "round", name: "Round", icon: "⭕" },
          { id: "u_shaped", name: "U-Shaped", icon: "🔄" },
          { id: "individual", name: "Individual", icon: "📦" },
        ];

        const OBSTACLE_TYPES = [
          {
            id: "teacher_desk",
            name: "Teacher Desk",
            color: "#8B4513",
            icon: "🪑",
          },
          { id: "cabinet", name: "Cabinet", color: "#654321", icon: "🗄️" },
          { id: "bookshelf", name: "Bookshelf", color: "#A0522D", icon: "📚" },
          { id: "door", name: "Door", color: "#228B22", icon: "🚪" },
          { id: "window", name: "Window", color: "#87CEEB", icon: "🪟" },
          {
            id: "whiteboard",
            name: "Whiteboard",
            color: "#F5F5F5",
            icon: "📋",
          },
          { id: "projector", name: "Projector", color: "#696969", icon: "📽️" },
          { id: "other", name: "Other", color: "#808080", icon: "⬛" },
        ];

        // Helper functions
        const getMousePosition = (e) => {
          const rect = canvasRef.current?.getBoundingClientRect();
          if (!rect) return { x: 0, y: 0 };
          return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        };

        const screenToGrid = (x, y) => {
          return {
            x: Math.floor(x / GRID_SIZE),
            y: Math.floor(y / GRID_SIZE),
          };
        };

        const gridToScreen = (x, y) => {
          return {
            x: x * GRID_SIZE,
            y: y * GRID_SIZE,
          };
        };

        const snapToGridIfEnabled = (x, y) => {
          if (snapToGrid) {
            return {
              x: Math.round(x / GRID_SIZE) * GRID_SIZE,
              y: Math.round(y / GRID_SIZE) * GRID_SIZE,
            };
          }
          return { x, y };
        };

        // Enhanced item detection utility
        const findItemAtPosition = (point) => {
          // Check tables first
          for (const table of layout.tables) {
            const itemX = table.x_position * GRID_SIZE;
            const itemY = table.y_position * GRID_SIZE;
            const itemWidth = table.width * GRID_SIZE;
            const itemHeight = table.height * GRID_SIZE;

            if (
              point.x >= itemX &&
              point.x <= itemX + itemWidth &&
              point.y >= itemY &&
              point.y <= itemY + itemHeight
            ) {
              return { item: table, type: "table" };
            }
          }

          // Then check obstacles
          for (const obstacle of layout.obstacles) {
            const itemX = obstacle.x_position * GRID_SIZE;
            const itemY = obstacle.y_position * GRID_SIZE;
            const itemWidth = obstacle.width * GRID_SIZE;
            const itemHeight = obstacle.height * GRID_SIZE;

            if (
              point.x >= itemX &&
              point.x <= itemX + itemWidth &&
              point.y >= itemY &&
              point.y <= itemY + itemHeight
            ) {
              return { item: obstacle, type: "obstacle" };
            }
          }

          return null;
        };

        // History management
        const saveToHistory = () => {
          const newHistory = history.slice(0, historyIndex + 1);
          newHistory.push(JSON.parse(JSON.stringify(layout)));
          setHistory(newHistory);
          setHistoryIndex(newHistory.length - 1);
        };

        const undo = () => {
          if (historyIndex > 0) {
            setHistoryIndex(historyIndex - 1);
            setLayout(JSON.parse(JSON.stringify(history[historyIndex - 1])));
          }
        };

        const redo = () => {
          if (historyIndex < history.length - 1) {
            setHistoryIndex(historyIndex + 1);
            setLayout(JSON.parse(JSON.stringify(history[historyIndex + 1])));
          }
        };

        // Generate seat positions based on table shape and max_seats
        const generateSeats = (tableShape, maxSeats, width = 2, height = 2) => {
          const seats = [];

          if (tableShape === "rectangular") {
            if (maxSeats <= 2) {
              seats.push(
                {
                  seat_number: 1,
                  x: 0.25,
                  y: 0.5,
                  accessibility_accommodations: false,
                },
                {
                  seat_number: 2,
                  x: 0.75,
                  y: 0.5,
                  accessibility_accommodations: false,
                }
              );
            } else if (maxSeats <= 4) {
              seats.push(
                {
                  seat_number: 1,
                  x: 0.25,
                  y: 0.25,
                  accessibility_accommodations: false,
                },
                {
                  seat_number: 2,
                  x: 0.75,
                  y: 0.25,
                  accessibility_accommodations: false,
                },
                {
                  seat_number: 3,
                  x: 0.75,
                  y: 0.75,
                  accessibility_accommodations: false,
                },
                {
                  seat_number: 4,
                  x: 0.25,
                  y: 0.75,
                  accessibility_accommodations: false,
                }
              );
            } else {
              // For larger tables, distribute seats around perimeter
              for (let i = 0; i < maxSeats; i++) {
                const angle = (i / maxSeats) * 2 * Math.PI;
                seats.push({
                  seat_number: i + 1,
                  x: 0.5 + 0.3 * Math.cos(angle),
                  y: 0.5 + 0.3 * Math.sin(angle),
                  accessibility_accommodations: false,
                });
              }
            }
          } else if (tableShape === "round") {
            // Arrange seats in a circle
            for (let i = 0; i < maxSeats; i++) {
              const angle = (i / maxSeats) * 2 * Math.PI;
              seats.push({
                seat_number: i + 1,
                x: 0.5 + 0.35 * Math.cos(angle),
                y: 0.5 + 0.35 * Math.sin(angle),
                accessibility_accommodations: false,
              });
            }
          } else {
            // Default arrangement for other shapes
            for (let i = 0; i < maxSeats; i++) {
              seats.push({
                seat_number: i + 1,
                x: 0.2 + (i % 3) * 0.3,
                y: 0.3 + Math.floor(i / 3) * 0.4,
                accessibility_accommodations: false,
              });
            }
          }

          return seats;
        };

        // Create new table
        const createTable = (gridX, gridY) => {
          saveToHistory();
          const newTable = {
            id: Date.now(),
            table_number: layout.tables.length + 1,
            table_name: `Table ${layout.tables.length + 1}`,
            x_position: Math.max(0, Math.min(gridX, layout.room_width - 2)),
            y_position: Math.max(0, Math.min(gridY, layout.room_height - 2)),
            width: 2,
            height: 2,
            max_seats: 4,
            table_shape: "rectangular",
            rotation: 0,
            seats: generateSeats("rectangular", 4, 2, 2),
          };

          setLayout((prev) => ({
            ...prev,
            tables: [...prev.tables, newTable],
          }));
          setSelectedItem({ type: "table", item: newTable });
        };

        // Create new obstacle
        const createObstacle = (gridX, gridY) => {
          saveToHistory();
          const obstacleType = OBSTACLE_TYPES[0];
          const newObstacle = {
            id: Date.now(),
            name: obstacleType.name,
            obstacle_type: obstacleType.id,
            x_position: Math.max(0, Math.min(gridX, layout.room_width - 1)),
            y_position: Math.max(0, Math.min(gridY, layout.room_height - 1)),
            width: 1,
            height: 1,
            color: obstacleType.color,
          };

          setLayout((prev) => ({
            ...prev,
            obstacles: [...prev.obstacles, newObstacle],
          }));
          setSelectedItem({ type: "obstacle", item: newObstacle });
        };

        // Delete selected item
        const deleteSelectedItem = () => {
          if (!selectedItem) return;

          saveToHistory();
          if (selectedItem.type === "table") {
            setLayout((prev) => ({
              ...prev,
              tables: prev.tables.filter((t) => t.id !== selectedItem.item.id),
            }));
          } else if (selectedItem.type === "obstacle") {
            setLayout((prev) => ({
              ...prev,
              obstacles: prev.obstacles.filter(
                (o) => o.id !== selectedItem.item.id
              ),
            }));
          }
          setSelectedItem(null);
        };

        // Duplicate selected item
        const duplicateSelectedItem = () => {
          if (!selectedItem) return;

          saveToHistory();
          const newItem = {
            ...selectedItem.item,
            id: Date.now(),
            x_position: Math.min(
              selectedItem.item.x_position + 1,
              layout.room_width - selectedItem.item.width
            ),
            y_position: Math.min(
              selectedItem.item.y_position + 1,
              layout.room_height - selectedItem.item.height
            ),
          };

          if (selectedItem.type === "table") {
            newItem.table_number = layout.tables.length + 1;
            newItem.table_name = `Table ${layout.tables.length + 1}`;
            setLayout((prev) => ({
              ...prev,
              tables: [...prev.tables, newItem],
            }));
          } else if (selectedItem.type === "obstacle") {
            setLayout((prev) => ({
              ...prev,
              obstacles: [...prev.obstacles, newItem],
            }));
          }

          setSelectedItem({ type: selectedItem.type, item: newItem });
        };

        // Rotate selected table
        const rotateSelectedTable = () => {
          if (!selectedItem || selectedItem.type !== "table") return;

          saveToHistory();
          const newRotation = (selectedItem.item.rotation + 90) % 360;

          setLayout((prev) => ({
            ...prev,
            tables: prev.tables.map((t) =>
              t.id === selectedItem.item.id
                ? { ...t, rotation: newRotation }
                : t
            ),
          }));

          setSelectedItem((prev) => ({
            ...prev,
            item: { ...prev.item, rotation: newRotation },
          }));
        };

        // Enhanced mouse handlers
        const handleMouseDown = (e) => {
          if (selectedTool !== "select") return;

          const mousePos = getMousePosition(e);
          const itemAtPos = findItemAtPosition(mousePos);

          if (itemAtPos) {
            e.preventDefault();
            e.stopPropagation();

            const itemX = itemAtPos.item.x_position * GRID_SIZE;
            const itemY = itemAtPos.item.y_position * GRID_SIZE;

            setDragState({
              isDragging: true,
              draggedItem: itemAtPos.item,
              draggedType: itemAtPos.type,
              startPosition: mousePos,
              offset: {
                x: mousePos.x - itemX,
                y: mousePos.y - itemY,
              },
            });

            setSelectedItem({ item: itemAtPos.item, type: itemAtPos.type });
          }
        };

        const handleMouseMove = (e) => {
          if (!dragState.isDragging || !dragState.draggedItem) return;

          e.preventDefault();
          const mousePos = getMousePosition(e);

          // Calculate new position
          const newX = mousePos.x - dragState.offset.x;
          const newY = mousePos.y - dragState.offset.y;

          // Convert to grid and constrain to room bounds
          const gridX = Math.round(newX / GRID_SIZE);
          const gridY = Math.round(newY / GRID_SIZE);
          const constrainedX = Math.max(
            0,
            Math.min(gridX, layout.room_width - dragState.draggedItem.width)
          );
          const constrainedY = Math.max(
            0,
            Math.min(gridY, layout.room_height - dragState.draggedItem.height)
          );

          // Update layout immediately for smooth dragging
          const updatedItem = {
            ...dragState.draggedItem,
            x_position: constrainedX,
            y_position: constrainedY,
          };

          if (dragState.draggedType === "table") {
            setLayout((prev) => ({
              ...prev,
              tables: prev.tables.map((t) =>
                t.id === dragState.draggedItem.id ? updatedItem : t
              ),
            }));
          } else if (dragState.draggedType === "obstacle") {
            setLayout((prev) => ({
              ...prev,
              obstacles: prev.obstacles.map((o) =>
                o.id === dragState.draggedItem.id ? updatedItem : o
              ),
            }));
          }

          setSelectedItem((prev) =>
            prev ? { ...prev, item: updatedItem } : null
          );
        };

        const handleMouseUp = () => {
          if (dragState.isDragging) {
            setDragState({
              isDragging: false,
              draggedItem: null,
              draggedType: null,
              startPosition: { x: 0, y: 0 },
              offset: { x: 0, y: 0 },
            });
          }
        };

        // Event handlers
        const handleCanvasClick = (e) => {
          const pos = getMousePosition(e);
          const gridPos = screenToGrid(pos.x, pos.y);

          if (selectedTool === "table") {
            createTable(gridPos.x, gridPos.y);
          } else if (selectedTool === "obstacle") {
            createObstacle(gridPos.x, gridPos.y);
          } else if (selectedTool === "select") {
            // Clear selection if clicking on empty space (only if not dragging)
            if (!dragState.isDragging) {
              setSelectedItem(null);
            }
          }
        };

        // Enhanced global mouse event listeners
        useEffect(() => {
          const handleGlobalMouseMove = (e) => handleMouseMove(e);
          const handleGlobalMouseUp = (e) => handleMouseUp(e);

          if (dragState.isDragging) {
            document.addEventListener("mousemove", handleGlobalMouseMove);
            document.addEventListener("mouseup", handleGlobalMouseUp);
            document.body.style.cursor = "grabbing";
            document.body.style.userSelect = "none";
          }

          return () => {
            document.removeEventListener("mousemove", handleGlobalMouseMove);
            document.removeEventListener("mouseup", handleGlobalMouseUp);
            document.body.style.cursor = "";
            document.body.style.userSelect = "";
          };
        }, [dragState.isDragging]);

        // Keyboard shortcuts
        useEffect(() => {
          const handleKeyDown = (e) => {
            if (e.ctrlKey || e.metaKey) {
              switch (e.key) {
                case "z":
                  e.preventDefault();
                  if (e.shiftKey) {
                    redo();
                  } else {
                    undo();
                  }
                  break;
                case "y":
                  e.preventDefault();
                  redo();
                  break;
                case "d":
                  e.preventDefault();
                  duplicateSelectedItem();
                  break;
              }
            } else {
              switch (e.key) {
                case "Delete":
                case "Backspace":
                  e.preventDefault();
                  deleteSelectedItem();
                  break;
                case "r":
                  e.preventDefault();
                  rotateSelectedTable();
                  break;
                case "Escape":
                  setSelectedItem(null);
                  setSelectedTool("select");
                  break;
              }
            }
          };

          window.addEventListener("keydown", handleKeyDown);
          return () => window.removeEventListener("keydown", handleKeyDown);
        }, [selectedItem, historyIndex, history]);

        // Save/Load functions
        const saveLayout = () => {
          const dataStr = JSON.stringify(layout, null, 2);
          const dataUri =
            "data:application/json;charset=utf-8," +
            encodeURIComponent(dataStr);
          const exportFileDefaultName = `${layout.name || "layout"}.json`;

          const linkElement = document.createElement("a");
          linkElement.setAttribute("href", dataUri);
          linkElement.setAttribute("download", exportFileDefaultName);
          linkElement.click();
        };

        const loadLayout = () => {
          fileInputRef.current?.click();
        };

        const handleFileLoad = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const importedLayout = JSON.parse(event.target.result);
              saveToHistory();
              setLayout(importedLayout);
              setSelectedItem(null);
            } catch (error) {
              alert("Error importing layout: Invalid file format");
            }
          };
          reader.readAsText(file);
        };

        // Initialize history
        useEffect(() => {
          if (history.length === 0) {
            setHistory([JSON.parse(JSON.stringify(layout))]);
            setHistoryIndex(0);
          }
        }, []);

        return (
          <div className="flex h-screen bg-gray-100">
            {/* Toolbar */}
            <div className="w-80 bg-white shadow-lg flex flex-col">
              {/* Header */}
              <div className="p-4 border-b border-gray-200">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-bold text-gray-800">
                    Layout Editor
                  </h2>
                  <div className="flex gap-2">
                    <button
                      onClick={() => setIsPreviewMode(!isPreviewMode)}
                      className={`p-2 rounded-lg transition-colors ${
                        isPreviewMode
                          ? "bg-blue-100 text-blue-600"
                          : "bg-gray-100 text-gray-600 hover:bg-gray-200"
                      }`}
                      title={isPreviewMode ? "Exit Preview" : "Preview Mode"}
                    >
                      {isPreviewMode
                        ? React.createElement(EyeOff, { size: 18 })
                        : React.createElement(Eye, { size: 18 })}
                    </button>
                  </div>
                </div>

                {/* Layout Info */}
                <div className="space-y-3">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Layout Name
                    </label>
                    <input
                      type="text"
                      value={layout.name}
                      onChange={(e) =>
                        setLayout((prev) => ({ ...prev, name: e.target.value }))
                      }
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      placeholder="Enter layout name"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Description
                    </label>
                    <textarea
                      value={layout.description}
                      onChange={(e) =>
                        setLayout((prev) => ({
                          ...prev,
                          description: e.target.value,
                        }))
                      }
                      className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      rows={2}
                      placeholder="Describe this layout"
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-3">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Width
                      </label>
                      <input
                        type="number"
                        value={layout.room_width}
                        onChange={(e) =>
                          setLayout((prev) => ({
                            ...prev,
                            room_width: Math.max(
                              5,
                              Math.min(30, parseInt(e.target.value) || 15)
                            ),
                          }))
                        }
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        min="5"
                        max="30"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Height
                      </label>
                      <input
                        type="number"
                        value={layout.room_height}
                        onChange={(e) =>
                          setLayout((prev) => ({
                            ...prev,
                            room_height: Math.max(
                              5,
                              Math.min(20, parseInt(e.target.value) || 10)
                            ),
                          }))
                        }
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        min="5"
                        max="20"
                      />
                    </div>
                  </div>
                </div>
              </div>

              {/* Tools */}
              <div className="p-4 border-b border-gray-200">
                <h3 className="text-sm font-semibold text-gray-700 mb-3">
                  Tools
                </h3>
                <div className="grid grid-cols-3 gap-2">
                  <button
                    onClick={() => setSelectedTool("select")}
                    className={`p-3 rounded-lg border-2 transition-all ${
                      selectedTool === "select"
                        ? "border-blue-500 bg-blue-50 text-blue-700"
                        : "border-gray-200 hover:border-gray-300 text-gray-600"
                    }`}
                    title="Select Tool"
                  >
                    <div className="flex flex-col items-center">
                      {React.createElement(MousePointer, { size: 20 })}
                      <span className="text-xs mt-1">Select</span>
                    </div>
                  </button>

                  <button
                    onClick={() => setSelectedTool("table")}
                    className={`p-3 rounded-lg border-2 transition-all ${
                      selectedTool === "table"
                        ? "border-blue-500 bg-blue-50 text-blue-700"
                        : "border-gray-200 hover:border-gray-300 text-gray-600"
                    }`}
                    title="Add Table"
                  >
                    <div className="flex flex-col items-center">
                      {React.createElement(Table, { size: 20 })}
                      <span className="text-xs mt-1">Table</span>
                    </div>
                  </button>

                  <button
                    onClick={() => setSelectedTool("obstacle")}
                    className={`p-3 rounded-lg border-2 transition-all ${
                      selectedTool === "obstacle"
                        ? "border-blue-500 bg-blue-50 text-blue-700"
                        : "border-gray-200 hover:border-gray-300 text-gray-600"
                    }`}
                    title="Add Obstacle"
                  >
                    <div className="flex flex-col items-center">
                      {React.createElement(Square, { size: 20 })}
                      <span className="text-xs mt-1">Obstacle</span>
                    </div>
                  </button>
                </div>
              </div>

              {/* Settings */}
              <div className="p-4 border-b border-gray-200">
                <h3 className="text-sm font-semibold text-gray-700 mb-3">
                  Settings
                </h3>
                <div className="space-y-3">
                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      checked={showGrid}
                      onChange={(e) => setShowGrid(e.target.checked)}
                      className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="ml-2 text-sm text-gray-600">
                      Show Grid
                    </span>
                  </label>

                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      checked={snapToGrid}
                      onChange={(e) => setSnapToGrid(e.target.checked)}
                      className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                    <span className="ml-2 text-sm text-gray-600">
                      Snap to Grid
                    </span>
                  </label>
                </div>
              </div>

              {/* Actions */}
              <div className="p-4 border-b border-gray-200">
                <h3 className="text-sm font-semibold text-gray-700 mb-3">
                  Actions
                </h3>
                <div className="space-y-2">
                  <div className="flex gap-2">
                    <button
                      onClick={undo}
                      disabled={historyIndex <= 0}
                      className="flex-1 px-3 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                      title="Undo (Ctrl+Z)"
                    >
                      Undo
                    </button>
                    <button
                      onClick={redo}
                      disabled={historyIndex >= history.length - 1}
                      className="flex-1 px-3 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                      title="Redo (Ctrl+Y)"
                    >
                      Redo
                    </button>
                  </div>

                  {selectedItem && (
                    <div className="space-y-2">
                      <button
                        onClick={duplicateSelectedItem}
                        className="w-full px-3 py-2 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 text-sm"
                        title="Duplicate (Ctrl+D)"
                      >
                        Duplicate
                      </button>

                      {selectedItem.type === "table" && (
                        <button
                          onClick={rotateSelectedTable}
                          className="w-full px-3 py-2 bg-green-100 text-green-700 rounded-lg hover:bg-green-200 text-sm"
                          title="Rotate (R)"
                        >
                          Rotate
                        </button>
                      )}

                      <button
                        onClick={deleteSelectedItem}
                        className="w-full px-3 py-2 bg-red-100 text-red-700 rounded-lg hover:bg-red-200 text-sm"
                        title="Delete (Del)"
                      >
                        Delete
                      </button>
                    </div>
                  )}
                </div>
              </div>

              {/* File Operations */}
              <div className="p-4 flex-1">
                <h3 className="text-sm font-semibold text-gray-700 mb-3">
                  File
                </h3>
                <div className="space-y-2">
                  <button
                    onClick={saveLayout}
                    className="w-full px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm flex items-center justify-center gap-2"
                  >
                    {React.createElement(Save, { size: 16 })}
                    Save Layout
                  </button>

                  <button
                    onClick={loadLayout}
                    className="w-full px-3 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 text-sm flex items-center justify-center gap-2"
                  >
                    {React.createElement(Upload, { size: 16 })}
                    Load Layout
                  </button>

                  <input
                    ref={fileInputRef}
                    type="file"
                    accept=".json"
                    onChange={handleFileLoad}
                    className="hidden"
                  />
                </div>

                {/* Stats */}
                <div className="mt-4 p-3 bg-gray-50 rounded-lg text-sm">
                  <div className="text-gray-600">
                    <div>Tables: {layout.tables.length}</div>
                    <div>Obstacles: {layout.obstacles.length}</div>
                    <div>
                      Total Seats:{" "}
                      {layout.tables.reduce(
                        (sum, table) => sum + (table.max_seats || 0),
                        0
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>

            {/* Canvas Area */}
            <div className="flex-1 flex flex-col bg-gray-50">
              {/* Canvas Header */}
              <div className="bg-white shadow-sm border-b border-gray-200 p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <h3 className="text-lg font-semibold text-gray-800">
                      {layout.name}
                    </h3>
                    <p className="text-sm text-gray-500">
                      {selectedTool === "select" &&
                        "Click to select items, drag to move"}
                      {selectedTool === "table" && "Click to place a new table"}
                      {selectedTool === "obstacle" &&
                        "Click to place a new obstacle"}
                    </p>
                  </div>
                  <div className="flex items-center gap-2">
                    {selectedItem && (
                      <div className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-medium">
                        {selectedItem.type === "table" ? "🪑" : "📦"}{" "}
                        {selectedItem.item.table_name || selectedItem.item.name}
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Canvas */}
              <div className="flex-1 overflow-auto p-8">
                <div
                  className="relative mx-auto border-2 border-gray-300 bg-white shadow-lg"
                  style={{
                    width: layout.room_width * GRID_SIZE,
                    height: layout.room_height * GRID_SIZE,
                  }}
                >
                  {/* Canvas for drawing */}
                  <canvas
                    ref={canvasRef}
                    width={layout.room_width * GRID_SIZE}
                    height={layout.room_height * GRID_SIZE}
                    className="absolute inset-0 select-none"
                    onClick={handleCanvasClick}
                    onMouseDown={handleMouseDown}
                    style={{
                      cursor: dragState.isDragging
                        ? "grabbing"
                        : selectedTool === "select"
                        ? "default"
                        : "crosshair",
                    }}
                  />

                  {/* Grid overlay */}
                  {showGrid && (
                    <div
                      className="absolute inset-0 pointer-events-none opacity-25"
                      style={{
                        backgroundImage: `
                            linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                            linear-gradient(to bottom, #e5e7eb 1px, transparent 1px)
                          `,
                        backgroundSize: `${GRID_SIZE}px ${GRID_SIZE}px`,
                      }}
                    />
                  )}

                  {/* Tables */}
                  {layout.tables.map((table) => {
                    const isSelected =
                      selectedItem?.item?.id === table.id &&
                      selectedItem?.type === "table";
                    const isDragging = dragState.draggedItem?.id === table.id;

                    return React.createElement(
                      "div",
                      {
                        key: table.id,
                        className: `absolute border-2 bg-blue-100 transition-all duration-200 ${
                          table.table_shape === "round"
                            ? "rounded-full"
                            : table.table_shape === "oval"
                            ? "rounded-full"
                            : "rounded-lg"
                        } ${
                          isSelected
                            ? "border-blue-500 shadow-lg ring-2 ring-blue-300 z-20"
                            : "border-blue-400 hover:border-blue-500 hover:shadow-md z-10"
                        } ${
                          selectedTool === "select"
                            ? "cursor-grab"
                            : "cursor-pointer"
                        }
                        ${isDragging ? "cursor-grabbing z-30" : ""}`,
                        style: {
                          left: table.x_position * GRID_SIZE,
                          top: table.y_position * GRID_SIZE,
                          width: table.width * GRID_SIZE,
                          height: table.height * GRID_SIZE,
                          transform: isDragging
                            ? "scale(1.05) rotate(1deg)"
                            : "scale(1)",
                          boxShadow: isDragging
                            ? "0 8px 32px rgba(0, 0, 0, 0.3)"
                            : undefined,
                          zIndex: isDragging ? 1000 : isSelected ? 100 : 10,
                        },
                        onMouseDown: handleMouseDown,
                        onClick: (e) => {
                          e.stopPropagation();
                          if (selectedTool === "select") {
                            setSelectedItem({ item: table, type: "table" });
                          }
                        },
                      },
                      [
                        // Table label
                        React.createElement(
                          "div",
                          {
                            className:
                              "absolute -top-6 left-0 bg-blue-600 text-white px-2 py-1 rounded text-xs font-semibold pointer-events-none shadow-sm",
                          },
                          table.table_name
                        ),

                        // Table number in center
                        React.createElement(
                          "div",
                          {
                            className:
                              "absolute inset-0 flex items-center justify-center text-blue-800 font-bold text-lg pointer-events-none shadow-text",
                          },
                          table.table_number
                        ),

                        // Seats
                        table.seats &&
                          table.seats.map((seat) => {
                            const isAccessible =
                              seat.accessibility_accommodations;
                            return React.createElement(
                              "div",
                              {
                                key: seat.seat_number,
                                className: `absolute w-6 h-6 border-2 rounded-full flex items-center justify-center text-xs font-bold pointer-events-none transition-all duration-200 ${
                                  isAccessible
                                    ? "bg-purple-300 border-purple-500 text-purple-800"
                                    : "bg-green-300 border-green-500 text-green-800"
                                }`,
                                style: {
                                  left: `calc(${seat.x * 100}% - 12px)`,
                                  top: `calc(${seat.y * 100}% - 12px)`,
                                },
                                title: isAccessible
                                  ? `Seat ${seat.seat_number} (Accessible)`
                                  : `Seat ${seat.seat_number}`,
                              },
                              seat.seat_number
                            );
                          }),
                      ]
                    );
                  })}

                  {/* Obstacles */}
                  {layout.obstacles.map((obstacle) => {
                    const isSelected =
                      selectedItem?.item?.id === obstacle.id &&
                      selectedItem?.type === "obstacle";
                    const isDragging =
                      dragState.draggedItem?.id === obstacle.id;

                    return React.createElement(
                      "div",
                      {
                        key: obstacle.id,
                        className: `absolute border-2 transition-all duration-200 ${
                          isSelected
                            ? "border-orange-500 shadow-lg ring-2 ring-orange-300 z-20"
                            : "border-gray-400 hover:border-gray-500 hover:shadow-md z-10"
                        } ${
                          selectedTool === "select"
                            ? "cursor-grab"
                            : "cursor-pointer"
                        }
                        ${isDragging ? "cursor-grabbing z-30" : ""}`,
                        style: {
                          left: obstacle.x_position * GRID_SIZE,
                          top: obstacle.y_position * GRID_SIZE,
                          width: obstacle.width * GRID_SIZE,
                          height: obstacle.height * GRID_SIZE,
                          backgroundColor: obstacle.color,
                          transform: isDragging
                            ? "scale(1.05) rotate(-1deg)"
                            : "scale(1)",
                          boxShadow: isDragging
                            ? "0 8px 32px rgba(0, 0, 0, 0.3)"
                            : undefined,
                          zIndex: isDragging ? 1000 : isSelected ? 100 : 10,
                        },
                        onMouseDown: handleMouseDown,
                        onClick: (e) => {
                          e.stopPropagation();
                          if (selectedTool === "select") {
                            setSelectedItem({
                              item: obstacle,
                              type: "obstacle",
                            });
                          }
                        },
                      },
                      React.createElement(
                        "div",
                        {
                          className:
                            "absolute inset-0 flex items-center justify-center text-xs font-semibold text-white pointer-events-none",
                          style: { textShadow: "0 1px 2px rgba(0, 0, 0, 0.5)" },
                        },
                        obstacle.name
                      )
                    );
                  })}

                  {/* Drag preview/ghost */}
                  {dragState.isDragging &&
                    React.createElement("div", {
                      className:
                        "absolute pointer-events-none opacity-30 border-2 border-dashed border-blue-400 bg-blue-100 rounded",
                      style: {
                        left: dragState.startPosition.x - dragState.offset.x,
                        top: dragState.startPosition.y - dragState.offset.y,
                        width: dragState.draggedItem.width * GRID_SIZE,
                        height: dragState.draggedItem.height * GRID_SIZE,
                      },
                    })}
                </div>
              </div>
            </div>
          </div>
        );
      };

      // Initialize the app
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(React.createElement(LayoutEditor));
    </script>
  </body>
</html>
